import java.util.*;
import java.io.*;
import ast.expr.binary.arithmatic.*;
import ast.expr.Expression;
import java_cup.runtime.*;


parser code
    {:
        private Scanner scanner;
        public Parser(Scanner scanner) {
            this.scanner = scanner;
        }
    :};

scan with {: return scanner.next_token(); :};


//TERMINALS

//keywords
terminal CONST, RECORD, BOOL, CHAR, INT, LONG, FLOAT, DOUBLE, STRING, VOID, TRUE, FALSE, EXTERN, AUTO, FUNCTION,
BEGIN, END, IF, ELSE, SWITCH, OF, CASE, DEFAULT, FOR, FOREACH, IN, REPEAT, UNTIL, BREAK, CONTINUE, RETURN, SIZEOF;

//operators
terminal SEMI, COL, COMA, DOT, BINOT, PLUS, MINUS, UMINUS, MULT, DIVIDE, MOD, ASSIGN, BIAND, BIOR, BIEXOR, NOT, AND,
OR, LT, GT, BRACKOP, BRACKCL, PRANTOP, PRANTCL, CASTPRANTOP, FUNCPRANTOP, PREFPLUS2, PREFMINUS2, POSTPLUS2, POSTMINUS2,
PLUSASSIGN, MINUSASSIGN, MULTASSIGN, DIVASSIGN, NOTEQ, EQEQ, LTEQ, GTEQ;

//literals
terminal CHAR_LIT, STR_LIT, INT_LIT, FLOAT_LIT, ID;


//NON TERMINALS

nonterminal program;
nonterminal program_part;

nonterminal global_var_dcl;
nonterminal variable_type;

nonterminal func_dcl;
nonterminal function_type;
nonterminal func_dcl_part;
nonterminal arguments;
nonterminal arguments_part;
nonterminal function_array_dcl;

nonterminal struct_dcl;
nonterminal struct_var_dcl;
nonterminal struct_more_var_dcl;
nonterminal struct_var_dcl_part;
nonterminal struct_type;

nonterminal block;
nonterminal block_content;
nonterminal loop_block;
nonterminal loop_block_content;

nonterminal var_dcl;
nonterminal var_dcl_part;
nonterminal var_dcl_cnt;
nonterminal var_dcl_cnt_part;
nonterminal var_dcl_cnt_extension;
nonterminal single_var;
nonterminal array_part;

nonterminal statement;
nonterminal loop_statement;

nonterminal cond_stmt;
nonterminal else_part;
nonterminal case_part;

nonterminal loop_stmt;
nonterminal loop_init_part;
nonterminal loop_cond_part;
nonterminal loop_update_part;

nonterminal assignment;
nonterminal variable;
nonterminal Expression expr;

nonterminal casting_type;
nonterminal arithmatic_expr;
nonterminal conditional_expr;
nonterminal const_val;
nonterminal function_call;
nonterminal parameters;
nonterminal parameters_part;


//PRECEDENCES

precedence right MULTASSIGN, DIVASSIGN;
precedence right PLUSASSIGN, MINUSASSIGN;
precedence right ASSIGN;
precedence left OR;
precedence left AND;
precedence left BIOR;
precedence left BIEXOR;
precedence left BIAND;
precedence left EQEQ, NOTEQ;
precedence left GT, GTEQ;
precedence left LT, LTEQ;
precedence left PLUS, MINUS;
precedence left MULT, DIVIDE, MOD;
precedence right SIZEOF;
precedence right NOT, BINOT;
precedence right CASTPRANTOP;
precedence right UMINUS;
precedence left PRANTOP;
precedence right PREFPLUS2, PREFMINUS2;
precedence left DOT;
precedence left BRACKOP;
precedence left FUNCPRANTOP;
precedence left POSTPLUS2, POSTMINUS2;


start with program;


//GRAMMER PRODUCTION RULES

//program
program ::=
    program_part program
    |
    /*epsilon*/
    ;

program_part ::=
    global_var_dcl
    |
    func_dcl
    |
    struct_dcl
    ;


//global variables
global_var_dcl ::=
    variable_type ID SEMI
    ;

variable_type ::=
    struct_type
    |
    STRING
    |
    ID
    ;


//functions
func_dcl ::=
    EXTERN function_type ID SEMI
    |
    FUNCTION function_type ID PRANTOP arguments PRANTCL func_dcl_part
    ;

function_type ::=
    variable_type
    |
    VOID
    ;

func_dcl_part ::=
    SEMI
    |
    block
    ;

arguments ::=
    variable_type ID function_array_dcl arguments_part
    |
    /*epsilon*/
    ;

arguments_part ::=
     COMA arguments
     |
     /*epsilon*/
    ;

function_array_dcl ::=
    BRACKOP BRACKCL function_array_dcl
    |
    /*epsilon*/
    ;


//structurs
struct_dcl ::=
    RECORD {:structname;:}ID {:new Struct(structname);:} BEGIN {:content;:} struct_var_dcl {:StructHandler.structhandler.getCurrent().addContent(content);:} struct_more_var_dcl END RECORD SEMI
    ;

struct_more_var_dcl ::=
   {:content;:} struct_var_dcl {:StructHandler.structhandler.getCurrent().addContent(content);:} struct_more_var_dcl
    |
    /*epsilon*/
    ;

struct_var_dcl ::=
    CONST {:content;:}struct_var_dcl_part SEMI {:StructHandler.structhandler.geCurrent().addcontent(content.setIsConst(true));:}
    |
    {:content;:} struct_var_dcl_part SEMI {:StructHandler.structhandler.geCurrent().addcontent(content.setIsConst(false));:}
    ;

struct_var_dcl_part ::=
    struct_type var_dcl_cnt var_dcl_cnt_extension {:new content(...):}
    ;

struct_type ::=
    casting_type
    |
    BOOL
    |
    LONG
    |
    AUTO
    ;


//blocks
block ::=
    BEGIN block_content END
    ;

block_content ::=
    var_dcl block_content
    |
    statement block_content
    |
    /*epsilon*/
    ;

loop_block ::=
    BEGIN loop_block_content END
    ;

loop_block_content ::=
    var_dcl loop_block_content
    |
    loop_statement loop_block_content
    |
    /*epsilon*/
    ;


//variables
var_dcl ::=
    CONST var_dcl_part SEMI
    |
    var_dcl_part SEMI
    ;

var_dcl_part ::=
    variable_type var_dcl_cnt var_dcl_cnt_extension
    ;

var_dcl_cnt ::=
    single_var var_dcl_cnt_part
    ;

var_dcl_cnt_part ::=
    ASSIGN expr
    |
    /*epsilon*/
    ;

var_dcl_cnt_extension ::=
    COMA var_dcl_cnt var_dcl_cnt_extension
    |
    /*epsilon*/
    ;

single_var ::=
    ID array_part
    ;

array_part ::=
    BRACKOP expr BRACKCL array_part
    |
    /*epsilon*/
    ;


//statements
statement ::=
    cond_stmt
    |
    loop_stmt
    |
    assignment SEMI
    |
    function_call SEMI
    |
    RETURN expr SEMI
    ;

loop_statement ::=
    statement
    |
    BREAK SEMI
    |
    CONTINUE SEMI
    ;


//conditionals
cond_stmt ::=
    IF PRANTOP expr PRANTCL block else_part
    |
    SWITCH PRANTOP ID PRANTCL OF COL BEGIN case_part DEFAULT COL block END
    ;

else_part ::=
    ELSE block
    |
    /*epsilon*/
    ;

case_part ::=
    CASE INT_LIT COL block case_part
    |
    /*epsilon*/
    ;


//loops
loop_stmt ::=
    FOR PRANTOP loop_init_part SEMI loop_cond_part SEMI loop_update_part PRANTCL loop_block
    |//in your grammer we shouldn't declare variable in for loop
    REPEAT loop_block UNTIL PRANTOP expr PRANTCL SEMI
    |
    FOREACH PRANTOP ID IN ID PRANTCL loop_block
    ;

loop_init_part ::=
    assignment
    |
    /*epsilon*/
    ;

loop_cond_part ::=
    expr
    |
    /*epsilon*/
    ;

loop_update_part ::=
    assignment
    |
    /*epsilon*/
    ;


//assignments
assignment ::=
    variable ASSIGN expr
    |
    variable PLUSASSIGN expr
    |
    variable MINUSASSIGN expr
    |
    variable MULTASSIGN expr
    |
    variable DIVASSIGN expr
    ;

variable ::=
    single_var
    |
    variable DOT ID
    |
    PREFMINUS2 variable
    |
    PREFPLUS2 variable
    |
    variable PREFMINUS2 %prec POSTMINUS2
    |
    variable PREFPLUS2 %prec POSTPLUS2
    ;


//expressions
expr ::=
    PRANTOP casting_type PRANTCL expr %prec CASTPRANTOP
    |
    arithmatic_expr
    |
    conditional_expr
    |
    PRANTOP expr PRANTCL
    |
    NOT expr
    |
    BINOT expr
    |
    MINUS expr %prec UMINUS
    |
    const_val
    |
    variable
    |
    function_call
    |
    SIZEOF PRANTOP variable_type PRANTCL
    ;

casting_type ::=
    CHAR
    |
    INT
    |
    FLOAT
    |
    DOUBLE
    ;

arithmatic_expr ::=
    expr MULT expr
    |
    expr DIVIDE expr
    |
    expr MOD expr
    |
    expr:e1 PLUS expr:e2 {:new Add(e1,e2).compile();:}
    |
    expr MINUS expr
    |
    expr BIAND expr
    |
    expr BIOR expr
    |
    expr BIEXOR expr
    ;

conditional_expr ::=
    expr LT expr
    |
    expr LTEQ expr
    |
    expr GT expr
    |
    expr GTEQ expr
    |
    expr EQEQ expr
    |
    expr NOTEQ expr
    |
    expr AND expr
    |
    expr OR expr
    ;

const_val ::=
    TRUE
    |
    FALSE
    |
    CHAR_LIT
    |
    INT_LIT
    |
    FLOAT_LIT
    |
    STR_LIT
    ;


//function calls
function_call ::=
    ID PRANTOP parameters PRANTCL %prec FUNCPRANTOP
    ;

parameters ::=
    expr parameters_part
    |
    /*epsilon*/
    ;

parameters_part ::=
    COMA parameters
    |
    /*epsilon*/
    ;